#!/usr/bin/env python3
"""
Phase 2: Exploits Database and Security Tools Downloader
Downloads exploit databases, security tools, and pentesting datasets.
"""

import os
import subprocess
import json
import shutil
from pathlib import Path
from typing import Dict, List, Tuple


class Phase2Downloader:
    """Downloads exploits database and security tools."""
    
    def __init__(self, base_dir: str = "./cybersecurity_datasets"):
        """Initialize the Phase 2 downloader.
        
        Args:
            base_dir: Base directory for all datasets
        """
        self.base_dir = Path(base_dir)
        self.phase_dir = self.base_dir / "phase2_exploits_tools"
        self.exploitdb_dir = self.phase_dir / "exploitdb"
        self.tools_dir = self.phase_dir / "security_tools"
        self.pentesting_dir = self.phase_dir / "pentesting_dataset"
        self.extracted_dir = self.phase_dir / "extracted_python_scripts"
        
        # Create directories
        self.phase_dir.mkdir(parents=True, exist_ok=True)
        self.tools_dir.mkdir(parents=True, exist_ok=True)
        self.pentesting_dir.mkdir(parents=True, exist_ok=True)
        self.extracted_dir.mkdir(parents=True, exist_ok=True)
        
        self.results = {
            "exploitdb": None,
            "security_tools": [],
            "pentesting_dataset": None,
            "extracted_scripts": 0,
            "errors": []
        }
    
    def clone_repo(self, url: str, target_dir: Path) -> Tuple[bool, str]:
        """Clone a git repository with error handling.
        
        Args:
            url: Git repository URL
            target_dir: Target directory for cloning
            
        Returns:
            Tuple of (success: bool, message: str)
        """
        try:
            if target_dir.exists():
                print(f"  ‚è≠Ô∏è  Already exists: {target_dir.name}")
                return True, f"Already exists: {target_dir.name}"
            
            print(f"  üì¶ Cloning {url}...")
            result = subprocess.run(
                ["git", "clone", "--depth", "1", url, str(target_dir)],
                capture_output=True,
                text=True,
                timeout=600  # 10 minutes for large repos
            )
            
            if result.returncode == 0:
                print(f"  ‚úÖ Successfully cloned to {target_dir.name}")
                return True, f"Successfully cloned: {target_dir.name}"
            else:
                error_msg = result.stderr.strip() or result.stdout.strip()
                print(f"  ‚ùå Failed to clone: {error_msg}")
                return False, f"Failed: {error_msg}"
                
        except subprocess.TimeoutExpired:
            error_msg = "Clone operation timed out after 10 minutes"
            print(f"  ‚ùå {error_msg}")
            return False, error_msg
        except Exception as e:
            error_msg = f"Error cloning repository: {str(e)}"
            print(f"  ‚ùå {error_msg}")
            return False, error_msg
    
    def download_exploitdb(self) -> bool:
        """Download Exploit Database from Offensive Security.
        
        Returns:
            bool: Success status
        """
        print("\nüí£ Downloading Exploit Database...")
        
        url = "https://github.com/offensive-security/exploitdb"
        success, message = self.clone_repo(url, self.exploitdb_dir)
        
        if success:
            self.results["exploitdb"] = {
                "url": url,
                "status": "success"
            }
        else:
            self.results["exploitdb"] = {
                "url": url,
                "status": "failed",
                "error": message
            }
            self.results["errors"].append(f"ExploitDB: {message}")
        
        return success
    
    def download_security_tools(self) -> int:
        """Download security tools repositories.
        
        Returns:
            int: Number of successfully cloned repositories
        """
        print("\nüîß Downloading Security Tools...")
        
        tools_repos = [
            ("https://github.com/SofianeHamlaoui/Lockdoor-Framework", "lockdoor_framework"),
            ("https://github.com/0x1CA3/AdbNet", "adbnet"),
            ("https://github.com/AlaBouali/bane", "bane"),
            ("https://github.com/OWASP/Nettacker", "nettacker"),
            ("https://github.com/Manisso/fsociety", "fsociety"),
            ("https://github.com/swisskyrepo/PayloadsAllTheThings", "payloadsallthethings")
        ]
        
        success_count = 0
        for url, dir_name in tools_repos:
            target_dir = self.tools_dir / dir_name
            success, message = self.clone_repo(url, target_dir)
            
            if success:
                success_count += 1
                self.results["security_tools"].append({
                    "url": url,
                    "directory": dir_name,
                    "status": "success"
                })
            else:
                self.results["security_tools"].append({
                    "url": url,
                    "directory": dir_name,
                    "status": "failed",
                    "error": message
                })
                self.results["errors"].append(f"Security tool {url}: {message}")
        
        return success_count
    
    def download_pentesting_dataset(self) -> bool:
        """Download pentesting dataset from Hugging Face.
        
        Returns:
            bool: Success status
        """
        print("\nüéØ Downloading Pentesting Dataset...")
        
        try:
            # Try to download from Hugging Face
            try:
                from huggingface_hub import snapshot_download
                
                print("  üì¶ Downloading Canstralian/pentesting_dataset from Hugging Face...")
                snapshot_download(
                    repo_id="Canstralian/pentesting_dataset",
                    repo_type="dataset",
                    local_dir=str(self.pentesting_dir),
                    local_dir_use_symlinks=False
                )
                print("  ‚úÖ Pentesting dataset downloaded")
                self.results["pentesting_dataset"] = "Downloaded from Hugging Face"
                return True
                
            except ImportError:
                print("  ‚ö†Ô∏è  huggingface_hub not installed")
                print("  üí° To download pentesting dataset, install: pip install huggingface-hub")
                print("  üí° Then run: huggingface-cli download Canstralian/pentesting_dataset")
                self.results["pentesting_dataset"] = "Manual download required"
                return False
            except Exception as e:
                print(f"  ‚ö†Ô∏è  Could not download from Hugging Face: {str(e)}")
                print("  üí° You may need to manually download the dataset")
                self.results["pentesting_dataset"] = f"Error: {str(e)}"
                return False
                
        except Exception as e:
            error_msg = f"Error with pentesting dataset: {str(e)}"
            print(f"  ‚ùå {error_msg}")
            self.results["errors"].append(error_msg)
            return False
    
    def extract_python_scripts(self) -> int:
        """Extract all Python scripts from downloaded repositories.
        
        Returns:
            int: Number of scripts extracted
        """
        print("\nüêç Extracting Python Scripts...")
        
        script_count = 0
        search_dirs = [self.exploitdb_dir, self.tools_dir]
        
        for search_dir in search_dirs:
            if not search_dir.exists():
                continue
            
            print(f"  üîç Searching in {search_dir.name}...")
            
            for py_file in search_dir.rglob("*.py"):
                try:
                    # Skip __pycache__ and other irrelevant files
                    if "__pycache__" in str(py_file) or ".git" in str(py_file):
                        continue
                    
                    # Create a unique name to avoid conflicts
                    relative_path = py_file.relative_to(search_dir)
                    target_name = str(relative_path).replace("/", "_").replace("\\", "_")
                    target_path = self.extracted_dir / target_name
                    
                    # Copy the file
                    shutil.copy2(py_file, target_path)
                    script_count += 1
                    
                except Exception as e:
                    # Skip files that can't be copied
                    continue
        
        print(f"  ‚úÖ Extracted {script_count} Python scripts")
        self.results["extracted_scripts"] = script_count
        
        return script_count
    
    def run(self) -> Dict:
        """Execute all Phase 2 downloads.
        
        Returns:
            Dict: Results summary
        """
        print("=" * 80)
        print("üí£ PHASE 2: Exploits Database & Security Tools")
        print("=" * 80)
        
        # Download ExploitDB
        exploitdb_success = self.download_exploitdb()
        
        # Download security tools
        tools_success = self.download_security_tools()
        
        # Download pentesting dataset
        pentesting_success = self.download_pentesting_dataset()
        
        # Extract Python scripts
        scripts_count = self.extract_python_scripts()
        
        # Print summary
        print("\n" + "=" * 80)
        print("üìä PHASE 2 SUMMARY")
        print("=" * 80)
        print(f"  ExploitDB: {'‚úÖ' if exploitdb_success else '‚ùå'}")
        print(f"  Security Tools: {tools_success}/6 successful")
        print(f"  Pentesting Dataset: {'‚úÖ' if pentesting_success else '‚ö†Ô∏è'}")
        print(f"  Extracted Python Scripts: {scripts_count}")
        
        if self.results["errors"]:
            print(f"\n  ‚ö†Ô∏è  {len(self.results['errors'])} errors occurred")
        
        print("=" * 80)
        
        # Save results
        results_file = self.phase_dir / "phase2_results.json"
        with open(results_file, "w") as f:
            json.dump(self.results, f, indent=2)
        
        return self.results


def main():
    """Main entry point for Phase 2 downloader."""
    import argparse
    
    parser = argparse.ArgumentParser(
        description="Download exploits database and security tools"
    )
    parser.add_argument(
        "--dir",
        default="./cybersecurity_datasets",
        help="Base directory for datasets (default: ./cybersecurity_datasets)"
    )
    
    args = parser.parse_args()
    
    downloader = Phase2Downloader(args.dir)
    downloader.run()


if __name__ == "__main__":
    main()
